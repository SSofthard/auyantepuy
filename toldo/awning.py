# -*- coding: utf-8 -*-
##############################################################################
#
#    OpenERP, Open Source Management Solution
#    Copyright (C) 2004-2010 Tiny SPRL (<http://tiny.be>).
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
##############################################################################
# Generated by the OpenERP plugin for Dia !
from openerp.osv import fields, osv
from datetime import datetime, date, time, timedelta
import time

class product_product(osv.Model):
    _inherit = "product.product"
    _columns = {
        'isawning':fields.boolean('Is Awning'),
        'iscategid':fields.boolean('Is categ id'),
        'isservice':fields.boolean('Is Service id'),
    }
    
class product_category(osv.Model):
    _inherit = "product.category"
    _columns = {
        'isawningtype':fields.boolean('Is awning Type'),
        'isamenitytype':fields.boolean('Is Amenities Type'),
        'isservicetype':fields.boolean('Is Service Type'),
    }
    
class toldo_awning_type(osv.Model):
    _name = "toldo.awning.type"
    _inherits = {'product.category': 'cat_id'}
    _description = "awning Type"
    _columns = {
        'cat_id': fields.many2one('product.category', 'category', required=True, select=True, ondelete='cascade'),
    }
    _defaults = {
        'isawningtype': 1,
    }
    
class toldo_awning_amenities_type(osv.Model):
    _name = 'toldo.awning.amenities.type'
    _description = 'amenities Type'
    _inherits = {'product.category':'cat_id'}
    _columns = {
        'cat_id':fields.many2one('product.category', 'category', required=True, ondelete='cascade'),
    }
    _defaults = {
        'isamenitytype': 1,
    }

class toldo_awning_amenities(osv.Model):
    _name = 'toldo.awning.amenities'
    _description = 'Awning amenities'
    _inherits = {'product.template': 'awning_categ_id'}
    
    def costos_total(self, cursor, user, ids, name, arg, context=None):
		res = {}
		precision = self.pool.get('decimal.precision').precision_get(cursor, user, 'Account')
		for awning in self.browse(cursor, user, ids, context=context):
			res[awning.id] = round((awning.list_price+(awning.list_price*awning.taxes_id.amount)),precision)
		return res
		
    _columns = {
        'costo_total': fields.function(costos_total, string='Costo total', type='float'),
        'awning_categ_id':fields.many2one('product.template', 'Product Category', required=True, ondelete='cascade'),
        'rcateg_id':fields.many2one('toldo.awning.amenities.type', 'Amenity Catagory'),
        #~ 'rcateg_id':fields.many2many('toldo.awning', 'Amenity Category','temp_tab_awning','rcateg_id','awning_amenities',''),
    }
    _defaults = {
        'iscategid': 1,
    }

class toldo_awning(osv.Model):
    _name = 'toldo.awning'
    _inherits = {'product.template': 'product_id'}
    _description = 'Awning'

    def costos_total(self, cursor, user, ids, name, arg, context=None):
		res = {}
		precision = self.pool.get('decimal.precision').precision_get(cursor, user, 'Account')
		for awning in self.browse(cursor, user, ids, context=context):
			res[awning.id] = round((awning.list_price+(awning.list_price*awning.taxes_id.amount)),precision)
		return res
		
    _columns = {
        'costo_total': fields.function(costos_total, string='Costo total', type='float'),
        'product_id': fields.many2one('product.template','product_id', required=True, ondelete='cascade'),
        'max_adult':fields.integer('Max Adultos'),
        'max_child':fields.integer('Max Ni√±os'),
        'awning_amenities':fields.many2many('toldo.awning.amenities', 'temp_tab_awning', 'awning_amenities', 'rcateg_id', 'Awning Amenities', help='List of Awning amenities. '),
        'status':fields.selection([('disponible', 'Disponible'), ('ocupado', 'Ocupado')], 'Status'),
    }
    

    _defaults = {
        'isawning':1,
        'rental':1,
        'qty_available':'1',
        'status': 'disponible',
        'max_adult':2,
        'website_published':1,
    }

    def set_awning_status_occupied(self, cr, uid, ids, context=None):
        return self.write(cr, uid, ids, {'status': 'ocupado'}, context=context)

    def set_awning_status_available(self, cr, uid, ids, context=None):
        return self.write(cr, uid, ids, {'status': 'disponible'}, context=context)    

class toldo_folio(osv.Model):

    def copy(self, cr, uid, id, default=None, context=None):
        return self.pool.get('sale.order').copy(cr, uid, id, default=None, context=None)

    def _invoiced(self, cursor, user, ids, name, arg, context=None):
        return self.pool.get('sale.order')._invoiced(cursor, user, ids, name, arg, context=None)

    def _invoiced_search(self, cursor, user, obj, name, args):
        return self.pool.get('sale.order')._invoiced_search(cursor, user, obj, name, args)

    _name = 'toldo.folio'
    _description = 'toldo folio new'
    _inherits = {'sale.order': 'order_id'}
    _rec_name = 'order_id'
    _order = 'id desc'
    _columns = {
      'name': fields.char('Folio Number', size=24, readonly=True),
      'order_id': fields.many2one('sale.order', 'Order', required=True, ondelete='cascade'),
      'checkin_date': fields.datetime('Check In', required=True, readonly=True, states={'draft':[('readonly', False)]}),
      'checkout_date': fields.datetime('Check Out', required=True, readonly=True, states={'draft':[('readonly', False)]}),
      'awning_lines': fields.one2many('toldo.folio.line', 'folio_id', readonly=True, states={'draft': [('readonly', False)], 'sent': [('readonly', False)]}, help="toldo awning reservation detail."),
      'service_lines': fields.one2many('toldo.service.line', 'folio_id', readonly=True, states={'draft': [('readonly', False)], 'sent': [('readonly', False)]}, help="toldo services detail provide to customer and it will include in main Invoice."),
      'toldo_policy': fields.selection([('prepaid', 'On Booking'), ('manual', 'On Check In'), ('picking', 'On Checkout')], 'toldo Policy', help="toldo policy for payment that either the guest has to payment at booking time or check-in check-out time."),
      'duration': fields.float('Duration in Days', readonly=True, help="Number of days which will automatically count from the check-in and check-out date. "),
    }
    _defaults = {
      'name': lambda obj, cr, uid, context: obj.pool.get('ir.sequence').get(cr, uid, 'toldo.folio'),
      'toldo_policy':'manual'
    }
    _sql_constraints = [
        ('check_in_out', 'CHECK (checkin_date<=checkout_date)', 'Check in Date Should be less than the Check Out Date!'),
    ]

    def _check_awning_vacant(self, cr, uid, ids, context=None):
        folio = self.browse(cr, uid, ids[0], context=context)
        awnings = []
        for awning in folio.awning_lines:
            if awning.product_id in awnings:
                return False
            awning.append(awning.product_id)
        return True

    _constraints = [
        (_check_awning_vacant, 'You cannot allocate the same awning twice!', ['awning_lines'])
    ]

    def onchange_dates(self, cr, uid, ids, checkin_date=False, checkout_date=False, duration=False):
        # This mathod gives the duration between check in checkout if customer will leave only for some hour it would be considers as
        # a whole day. If customer will checkin checkout for more or equal hours , which configured in company as additional hours than
        # it would be consider as full day
        value = {}
        company_obj = self.pool.get('res.company')
        configured_addition_hours = 0
        company_ids = company_obj.search(cr, uid, [])
        if company_ids:
            company = company_obj.browse(cr, uid, company_ids[0])
            configured_addition_hours = company.additional_hours
        if not duration:
            duration = 0
            if checkin_date and checkout_date:
                chkin_dt = datetime.strptime(checkin_date, '%Y-%m-%d %H:%M:%S')
                chkout_dt = datetime.strptime(checkout_date, '%Y-%m-%d %H:%M:%S')
                dur = chkout_dt - chkin_dt
                duration = dur.days
                if configured_addition_hours > 0:
                    additional_hours = abs((dur.seconds / 60) / 60)
                    if additional_hours >= configured_addition_hours:
                        duration += 1
            value.update({'value':{'duration':duration}})
        else:
            if checkin_date:
                chkin_dt = datetime.strptime(checkin_date, '%Y-%m-%d %H:%M:%S')
                chkout_dt = chkin_dt + timedelta(days=duration)
                checkout_date = datetime.strftime(chkout_dt, '%Y-%m-%d %H:%M:%S')
                value.update({'value':{'checkout_date':checkout_date}})
        return value

    def create(self, cr, uid, vals, context=None, check=True):
        tmp_awning_lines = vals.get('awning_lines', [])
        vals['order_policy'] = vals.get('toldo_policy', 'manual')
        if not 'service_lines' and 'folio_id' in vals:
                vals.update({'awning_lines':[]})
                folio_id = super(toldo_folio, self).create(cr, uid, vals, context=context)
                for line in (tmp_awning_lines):
                    line[2].update({'folio_id':folio_id})
                vals.update({'awning_lines':tmp_awning_lines})
                super(toldo_folio, self).write(cr, uid, [folio_id], vals, context=context)
        else:
            folio_id = super(toldo_folio, self).create(cr, uid, vals, context=context)
        return folio_id

    def onchange_warehouse_id(self, cr, uid, ids, warehouse_id):
        order_ids = [folio.order_id.id for folio in self.browse(cr, uid, ids)]
        return self.pool.get('sale.order').onchange_warehouse_id(cr, uid, order_ids, warehouse_id)

    def onchange_partner_id(self, cr, uid, ids, part, context=None):
        res = {}
        if part:
            partner_rec = self.pool.get('res.partner').browse(cr, uid, part, context=context)
            order_ids = [folio.order_id.id for folio in self.browse(cr, uid, ids, context=context)]
            if not order_ids:
                res['value'] = {'partner_invoice_id': partner_rec.id , 'pricelist_id':partner_rec.property_product_pricelist.id}
                res['warning'] = {'title': _('Warning'), 'message': _('Not Any Order For  %s ' % (partner_rec.name))}
            else:
                res['value'] = {'partner_invoice_id': partner_rec.id, 'pricelist_id':partner_rec.property_product_pricelist.id}
        return res

    def button_dummy(self, cr, uid, ids, context=None):
        order_ids = [folio.order_id.id for folio in self.browse(cr, uid, ids)]
        hola=self.pool.get('sale.order').button_dummy(cr, uid, order_ids, context={})
        return self.pool.get('sale.order').button_dummy(cr, uid, order_ids, context={})

    def action_invoice_create(self, cr, uid, ids, grouped=False, states=['confirmed', 'done']):
        order_ids = [folio.order_id.id for folio in self.browse(cr, uid, ids)]
        invoice_id = self.pool.get('sale.order').action_invoice_create(cr, uid, order_ids, grouped=False, states=['confirmed', 'done'])
        for line in self.browse(cr, uid, ids):
            values = {
                'invoiced': True,
                'state': 'progress' if grouped else 'progress',
            }
            line.write(values)
        return invoice_id

    def action_invoice_cancel(self, cr, uid, ids, context=None):
        order_ids = [folio.order_id.id for folio in self.browse(cr, uid, ids)]
        res = self.pool.get('sale.order').action_invoice_cancel(cr, uid, order_ids, context=context)
        for sale in self.browse(cr, uid, ids, context=context):
            for line in sale.order_line:
                line.write({'invoiced': 'invoiced'})
        self.write(cr, uid, ids, {'state':'invoice_except'}, context=context)
        return res

    def action_cancel(self, cr, uid, ids, context=None):
        order_ids = [folio.order_id.id for folio in self.browse(cr, uid, ids, context=context)]
        rv = self.pool.get('sale.order').action_cancel(cr, uid, order_ids, context=context)
        wf_service = netsvc.LocalService("workflow")
        for sale in self.browse(cr, uid, ids, context=context):
            for pick in sale.picking_ids:
                wf_service.trg_validate(uid, 'stock.picking', pick.id, 'button_cancel', cr)
            for invoice in sale.invoice_ids:
                wf_service.trg_validate(uid, 'account.invoice', invoice.id, 'invoice_cancel', cr)
                sale.write({'state':'cancel'})
        return rv

    def action_wait(self, cr, uid, ids, *args):
        sale_order_obj = self.pool.get('sale.order')
        res = False
        for o in self.browse(cr, uid, ids):
            res = sale_order_obj.action_wait(cr, uid, [o.order_id.id], *args)
            if (o.order_policy == 'manual') and (not o.invoice_ids):
                self.write(cr, uid, [o.id], {'state': 'manual'})
            else:
                self.write(cr, uid, [o.id], {'state': 'progress'})
        return res

    def test_state(self, cr, uid, ids, mode, *args):
        write_done_ids = []
        write_cancel_ids = []
        if write_done_ids:
            self.pool.get('sale.order.line').write(cr, uid, write_done_ids, {'state': 'done'})
        if write_cancel_ids:
            self.pool.get('sale.order.line').write(cr, uid, write_cancel_ids, {'state': 'cancel'})
        return True

    def procurement_lines_get(self, cr, uid, ids, *args):
        order_ids = [folio.order_id.id for folio in self.browse(cr, uid, ids)]
        # return self.pool.get('sale.order').procurement_lines_get(cr, uid, order_ids, *args)
        return True
    def action_ship_create(self, cr, uid, ids, context=None):
        order_ids = [folio.order_id.id for folio in self.browse(cr, uid, ids)]
        return self.pool.get('sale.order').action_ship_create(cr, uid, order_ids, context=None)

    def action_ship_end(self, cr, uid, ids, context=None):
        order_ids = [folio.order_id.id for folio in self.browse(cr, uid, ids)]
        for order in self.browse(cr, uid, ids, context=context):
            order.write ({'shipped':True})
        return True

    def has_stockable_products(self, cr, uid, ids, *args):
        order_ids = [folio.order_id.id for folio in self.browse(cr, uid, ids)]
        return self.pool.get('sale.order').has_stockable_products(cr, uid, order_ids, *args)

    def action_cancel_draft(self, cr, uid, ids, *args):
        if not len(ids):
            return False
        cr.execute('select id from sale_order_line where order_id IN %s and state=%s', (tuple(ids), 'cancel'))
        line_ids = map(lambda x: x[0], cr.fetchall())
        self.write(cr, uid, ids, {'state': 'draft', 'invoice_ids': [], 'shipped': 0})
        self.pool.get('sale.order.line').write(cr, uid, line_ids, {'invoiced': False, 'state': 'draft', 'invoice_lines': [(6, 0, [])]})
        wf_service = netsvc.LocalService("workflow")
        for inv_id in ids:
            # Deleting the existing instance of workflow for SO
            wf_service.trg_delete(uid, 'sale.order', inv_id, cr)
            wf_service.trg_create(uid, 'sale.order', inv_id, cr)
        for (id, name) in self.name_get(cr, uid, ids):
            message = _("The sales order '%s' has been set in draft state.") % (name,)
            self.log(cr, uid, id, message)
        return True





class toldo_folio_line(osv.Model):

    def copy(self, cr, uid, id, default=None, context=None):
        return self.pool.get('sale.order.line').copy(cr, uid, id, default=None, context=context)

    def _amount_line(self, cr, uid, ids, field_name, arg, context):
        return self.pool.get('sale.order.line')._amount_line(cr, uid, ids, field_name, arg, context)

    def _number_packages(self, cr, uid, ids, field_name, arg, context):
        return self.pool.get('sale.order.line')._number_packages(cr, uid, ids, field_name, arg, context)

    def _get_checkin_date(self, cr, uid, context=None):
        if 'checkin_date' in context:
            return context['checkin_date']
        return time.strftime('%Y-%m-%d %H:%M:%S')

    def _get_checkout_date(self, cr, uid, context=None):
        if 'checkin_date' in context:
            return context['checkout_date']
        return time.strftime('%Y-%m-%d %H:%M:%S')

    _name = 'toldo.folio.line'
    _description = 'toldo folio1 awning line'
    _inherits = {'sale.order.line':'order_line_id'}
    _columns = {
        'order_line_id': fields.many2one('sale.order.line', 'Order Line', required=True, ondelete='cascade'),
        'folio_id': fields.many2one('toldo.folio', 'Folio', ondelete='cascade'),
        'checkin_date': fields.datetime('Check In', required=True),
        'checkout_date': fields.datetime('Check Out', required=True),
    }
    _defaults = {
        'checkin_date':_get_checkin_date,
        'checkout_date':_get_checkout_date,
    }

    def create(self, cr, uid, vals, context=None, check=True):
        if 'folio_id' in vals:
            folio = self.pool.get("toldo.folio").browse(cr, uid, vals['folio_id'], context=context)
            vals.update({'order_id':folio.order_id.id})
        return super(osv.Model, self).create(cr, uid, vals, context)

    def unlink(self, cr, uid, ids, context=None):
        sale_line_obj = self.pool.get('sale.order.line')
        for line in self.browse(cr, uid, ids, context=context):
            if line.order_line_id:
                sale_line_obj.unlink(cr, uid, [line.order_line_id.id], context=context)
        return super(toldo_folio_line, self).unlink(cr, uid, ids, context=None)

    def uos_change(self, cr, uid, ids, product_uos, product_uos_qty=0, product_id=None):
        line_ids = [folio.order_line_id.id for folio in self.browse(cr, uid, ids)]
        return  self.pool.get('sale.order.line').uos_change(cr, uid, line_ids, product_uos, product_uos_qty=0, product_id=None)

    def product_id_change(self, cr, uid, ids, pricelist, product, qty=0,
            uom=False, qty_uos=0, uos=False, name='', partner_id=False,
            lang=False, update_tax=True, date_order=False):
        line_ids = [folio.order_line_id.id for folio in self.browse(cr, uid, ids)]
        return self.pool.get('sale.order.line').product_id_change(cr, uid, line_ids, pricelist, product, qty=0,
            uom=False, qty_uos=0, uos=False, name='', partner_id=partner_id,
            lang=False, update_tax=True, date_order=False)

    def product_uom_change(self, cursor, user, ids, pricelist, product, qty=0,
            uom=False, qty_uos=0, uos=False, name='', partner_id=False,
            lang=False, update_tax=True, date_order=False):
        return self.product_id_change(cursor, user, ids, pricelist, product, qty=0,
            uom=False, qty_uos=0, uos=False, name='', partner_id=partner_id,
            lang=False, update_tax=True, date_order=False)

    def on_change_checkout(self, cr, uid, ids, checkin_date=None, checkout_date=None, context=None):
        if not checkin_date:
            checkin_date = time.strftime('%Y-%m-%d %H:%M:%S')
        if not checkout_date:
            checkout_date = time.strftime('%Y-%m-%d %H:%M:%S')
        qty = 1
        if checkout_date < checkin_date:
            raise osv.except_osv(_('Error !'), _('Checkout must be greater or equal checkin date'))
        if checkin_date:
            diffDate = datetime(*time.strptime(checkout_date, '%Y-%m-%d %H:%M:%S')[:5]) - datetime(*time.strptime(checkin_date, '%Y-%m-%d %H:%M:%S')[:5])
            qty = diffDate.days
            if qty == 0:
                qty = 1
        return {'value':{'product_uom_qty':qty}}

    def button_confirm(self, cr, uid, ids, context=None):
        line_ids = [folio.order_line_id.id for folio in self.browse(cr, uid, ids)]
        return self.pool.get('sale.order.line').button_confirm(cr, uid, line_ids, context=context)

    def button_done(self, cr, uid, ids, context=None):
        line_ids = [folio.order_line_id.id for folio in self.browse(cr, uid, ids)]
        res = self.pool.get('sale.order.line').button_done(cr, uid, line_ids, context=context)
        wf_service = netsvc.LocalService("workflow")
        res = self.write(cr, uid, ids, {'state':'done'})
        for line in self.browse(cr, uid, ids, context):
            wf_service.trg_write(uid, 'sale.order', line.order_line_id.order_id.id, cr)
        return res

    def copy_data(self, cr, uid, id, default=None, context=None):
        line_id = self.browse(cr, uid, id).order_line_id.id
        return self.pool.get('sale.order.line').copy_data(cr, uid, line_id, default=None, context=context)

class toldo_service_line(osv.Model):

    def copy(self, cr, uid, id, default=None, context=None):
        line_id = self.browse(cr, uid, id).service_line_id.id
        return self.pool.get('sale.order.line').copy(cr, uid, line_id, default=None, context=context)

    def _amount_line(self, cr, uid, ids, field_name, arg, context):
        line_ids = [folio.service_line_id.id for folio in self.browse(cr, uid, ids)]
        return  self.pool.get('sale.order.line')._amount_line(cr, uid, line_ids, field_name, arg, context)

    def _number_packages(self, cr, uid, ids, field_name, arg, context):
        line_ids = [folio.service_line_id.id for folio in self.browse(cr, uid, ids)]
        return self.pool.get('sale.order.line')._number_packages(cr, uid, line_ids, field_name, arg, context)

    _name = 'toldo.service.line'
    _description = 'toldo Service line'
    _inherits = {'sale.order.line':'service_line_id'}
    _columns = {
        'service_line_id': fields.many2one('sale.order.line', 'Service Line', required=True, ondelete='cascade'),
        'folio_id': fields.many2one('toldo.folio', 'Folio', ondelete='cascade'),
    }

    def create(self, cr, uid, vals, context=None, check=True):
        if 'folio_id' in vals:
            folio = self.pool.get("toldo.folio").browse(cr, uid, vals['folio_id'], context=context)
            vals.update({'order_id':folio.order_id.id})
        return super(osv.Model, self).create(cr, uid, vals, context=context)

    def unlink(self, cr, uid, ids, context=None):
        sale_line_obj = self.pool.get('sale.order.line')
        for line in self.browse(cr, uid, ids, context=context):
            if line.service_line_id:
                sale_line_obj.unlink(cr, uid, [line.service_line_id.id], context=context)
        return super(toldo_service_line, self).unlink(cr, uid, ids, context=None)

    def product_id_change(self, cr, uid, ids, pricelist, product, qty=0,
            uom=False, qty_uos=0, uos=False, name='', partner_id=False,
            lang=False, update_tax=True, date_order=False):
        line_ids = [folio.service_line_id.id for folio in self.browse(cr, uid, ids)]
        return self.pool.get('sale.order.line').product_id_change(cr, uid, line_ids, pricelist, product, qty=0,
            uom=False, qty_uos=0, uos=False, name='', partner_id=partner_id,
            lang=False, update_tax=True, date_order=False)

    def product_uom_change(self, cursor, user, ids, pricelist, product, qty=0,
            uom=False, qty_uos=0, uos=False, name='', partner_id=False,
            lang=False, update_tax=True, date_order=False):
        return self.product_id_change(cursor, user, ids, pricelist, product, qty=0,
            uom=False, qty_uos=0, uos=False, name='', partner_id=partner_id,
            lang=False, update_tax=True, date_order=False)

    def on_change_checkout(self, cr, uid, ids, checkin_date=None, checkout_date=None, context=None):
        if not checkin_date:
            checkin_date = time.strftime('%Y-%m-%d %H:%M:%S')
        if not checkout_date:
            checkout_date = time.strftime('%Y-%m-%d %H:%M:%S')
        qty = 1
        if checkout_date < checkin_date:
            raise osv.except_osv(_('Error !'), _('Checkout must be greater or equal checkin date'))
        if checkin_date:
            diffDate = datetime.datetime(*time.strptime(checkout_date, '%Y-%m-%d %H:%M:%S')[:5]) - datetime.datetime(*time.strptime(checkin_date, '%Y-%m-%d %H:%M:%S')[:5])
            qty = diffDate.days
        return {'value':{'product_uom_qty':qty}}

    def button_confirm(self, cr, uid, ids, context=None):
        line_ids = [folio.service_line_id.id for folio in self.browse(cr, uid, ids)]
        return self.pool.get('sale.order.line').button_confirm(cr, uid, line_ids, context=context)

    def button_done(self, cr, uid, ids, context=None):
        line_ids = [folio.service_line_id.id for folio in self.browse(cr, uid, ids)]
        return self.pool.get('sale.order.line').button_done(cr, uid, line_ids, context=context)

    def uos_change(self, cr, uid, ids, product_uos, product_uos_qty=0, product_id=None):
        line_ids = [folio.service_line_id.id for folio in self.browse(cr, uid, ids)]
        return self.pool.get('sale.order.line').uos_change(cr, uid, line_ids, product_uos, product_uos_qty=0, product_id=None)

    def copy_data(self, cr, uid, id, default=None, context=None):
        line_id = self.browse(cr, uid, id).service_line_id.id
        return self.pool.get('sale.order.line').copy_data(cr, uid, line_id, default=default, context=context)

class awning_service_type(osv.Model):
    _name = "awning.service.type"
    _inherits = {'product.category':'ser_id'}
    _description = "Service Type"
    _columns = {
        'ser_id':fields.many2one('product.category', 'category', required=True, select=True, ondelete='cascade'),
    }
    _defaults = {
        'isservicetype': 1,
    }
    
class awning_services(osv.Model):
        _name = 'awning.services'
        _description = 'Awning Services and its charges'
        _inherits = {'product.template': 'service_id'}
    
        def costos_total(self, cursor, user, ids, name, arg, context=None):
                res = {}
                precision = self.pool.get('decimal.precision').precision_get(cursor, user, 'Account')
                for serv in self.browse(cursor, user, ids, context=context):
                    res[serv.id] = round((serv.list_price+(serv.list_price*serv.taxes_id.amount)),precision)
                return res
        
        
        _columns = {
            'costo_total': fields.function(costos_total, string='Costo total', type='float'),
            'service_id': fields.many2one('product.template', 'Service_id', required=True, ondelete='cascade'),
        }
        _defaults = {
            'isservice': 1,
        }
    
class res_company(osv.osv):
    _inherit = 'res.company'
    _columns = {
        'additional_hours': fields.integer('Additional Hours', help="Provide the min hours value for check in, checkout days, whatever the hours will be provided here based on that extra days will be calculated."),
    }
